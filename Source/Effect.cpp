//
// Created by bryan on 2/25/20.
//

#include "Actor.h"
#include "Action.h"
#include "Effect.h"
#include "Dice.h"
#include "Output.h"

// EffectHealing **************************************************************************************

bool EffectHealing::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    OUT_ALL << "        " << user.Name << " recovers " ALL_CONT
    int mod = HealingBonus + user.GetStatMod(KeyAttribute) + int(AddLevelMod * float(user.Stats->HDNum));
    int roll = HealingDie->RollMod(mod, HealingDieNum);
    OUT_ALL << " HP." ALL_CONT
    int heal_amount = target->Heal(mod + roll);
    if (heal_amount != mod + roll) OUT_ALL << " Reduced to " << heal_amount << "." ALL_CONT
    OUT_ALL ALL_ENDL

    return true;
}

void EffectHealing::EndEffect(Actor * effected) const
{}

bool EffectHealing::CanEffect(const Actor & user, const Actor * target) const
{
    // Don't try to heal a full HP target.
    return !target->HasCondition(NoHealing) && target->CurrentHP() < target->MaxHP();
}

// EffectExtraActions **************************************************************************************

bool EffectExtraActions::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    bool took_action = false;

    for (int i = 0; i < ExtraActions; ++i)
        if (user.TakeAction())
            took_action = true;

    for (int i = 0; i < ExtraBonusActions; ++i)
        if (user.TakeBonusAction())
            took_action = true;

    return took_action;
}

void EffectExtraActions::EndEffect(Actor * effected) const
{}

bool EffectExtraActions::CanEffect(const Actor & user, const Actor * target) const
{
    return true;
}

// EffectDamage **************************************************************************************

bool EffectDamage::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    if (!target->Conscious())
        return false;

    OUT_ALL << "        " << target->Name << " takes " ALL_CONT
    int mod = DamageBonus;

    if (target->HasImmunity(DamageType))
    {
        OUT_ALL << "no damage." ALL_ENDL
        return false;
    }

    int damage = 0;
    if (critical)
        damage = DamageDie->RollMod(mod, 2 * DamageDieNum);
    else
        damage = DamageDie->RollMod(mod, DamageDieNum);

    if (DamageMultiplier != 1)
    {
        damage = std::floor(float(damage) * DamageMultiplier);
        OUT_ALL << " scaled to " << damage ALL_CONT
    }
    if (target->HasResistance(DamageType))
    OUT_ALL << " resisted to " << damage / 2 ALL_CONT
    OUT_ALL << " " << DamageType << " damage." ALL_ENDL

    if (damage < 0)
    OUT_ERROR << "Negative damage dealt." << ERROR_END;

    target->TakeDamage(damage, DamageType, user);
    return true;
}

void EffectDamage::EndEffect(Actor * effected) const
{}

bool EffectDamage::CanEffect(const Actor & user, const Actor * target) const
{
    // Can only affect conscious and not-immune creatures.
    return target->Conscious() && !target->HasImmunity(DamageType);
}

// DamageBonusEffect **************************************************************************************

bool DamageBonusEffect::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    target->TempDamageBonus += BonusDamage;
    return true;
}

void DamageBonusEffect::EndEffect(Actor * effected) const
{
    effected->TempDamageBonus -= BonusDamage;
    OUT_ALL << "        " << effected->Name << " loses damage bonus of " << BonusDamage ALL_CONT
}

bool DamageBonusEffect::CanEffect(const Actor & user, const Actor * target) const
{
    return true;
}

// ResistanceEffect **************************************************************************************

bool ResistanceEffect::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    target->AddResistance(ResistanceType);
    return true;
}

void ResistanceEffect::EndEffect(Actor * effected) const
{
    effected->RemoveResistance(ResistanceType);
    OUT_ALL << "        " << effected->Name << " loses resistance to " << ResistanceType ALL_CONT
}

bool ResistanceEffect::CanEffect(const Actor & user, const Actor * target) const
{
    // We can affect targets that are already immune, but shouldn't try usually.
    return target->HasResistance(ResistanceType);
}

// UsableAction **************************************************************************************

// Local storage to keep track of extra ActionInstances generated by the UsableAction effect.
static std::vector<std::pair<const UsableAction *, ActionInstance *>> GeneratedInstances;

bool UsableAction::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    auto action_instance = new ActionInstance{ActionInst->Action, ActionInst->Uses, key_stat};
    if (ActionType == "Action")
        target->ActionQueue.push_front(ActionInstance{*action_instance});
    else if (ActionType == "Bonus")
        target->BonusActionQueue.push_front(ActionInstance{*action_instance});

    OUT_ALL << "        " << target->Name << " can now use " << ActionInst->Action->Name << "." ALL_ENDL

    // Add to the list so the generated action can be deleted later.
    GeneratedInstances.emplace_back(std::make_pair(this, action_instance));
    return true;
}

bool Check(const std::pair<const UsableAction *, ActionInstance *> & pair)
{
    return pair.second == nullptr;
}

UsableAction::~UsableAction()
{
    // Delete all generated ActionInstances paired to this effect.
    for (auto pair : GeneratedInstances)
        if (pair.first == this)
        {
            delete pair.second;
            pair.second = nullptr;
        }

    GeneratedInstances.erase(
            std::remove_if(GeneratedInstances.begin(), GeneratedInstances.end(), Check),
            GeneratedInstances.end());

    delete ActionInst;
}

bool RemoveFirstAction(ActionList & list, const std::shared_ptr<const Action> & action)
{
    auto prev = list.before_begin();
    auto curr = list.begin();
    while (curr != list.end())
    {
        if (curr->Action == action)
        {
            list.erase_after(prev);
            return true;
        }
        prev = curr++;
    }
    return false;
}

void UsableAction::EndEffect(Actor * effected) const
{
    if (ActionType == "Action")
        RemoveFirstAction(effected->ActionQueue, ActionInst->Action);
    else if (ActionType == "Bonus")
        RemoveFirstAction(effected->BonusActionQueue, ActionInst->Action);
    OUT_ALL << "        " << effected->Name << " can no longer use " << ActionInst->Action->Name << "." ALL_ENDL
}

bool UsableAction::CanEffect(const Actor & user, const Actor * target) const
{
    return true;
}

// SaveEffect **************************************************************************************

SaveEffect::~SaveEffect()
{
    for (Effect * e : HitEffects)
        delete e;
    for (Effect * e : MissEffects)
        delete e;
}

bool SaveEffect::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    bool made_save = target->MakeSave(SavingThrow, DC, user, false);

    // Rider effects can't crit.
    if (made_save)
        for (Effect * e : MissEffects)
            e->DoEffect(user, target, false, key_stat);
    else
        for (Effect * e : HitEffects)
            e->DoEffect(user, target, false, key_stat);

    return true;
}

void SaveEffect::EndEffect(Actor * effected) const
{
    for (Effect * e : HitEffects)
        e->EndEffect(effected);
    for (Effect * e : MissEffects)
        e->EndEffect(effected);
}

bool SaveEffect::CanEffect(const Actor & user, const Actor * target) const
{
    for (Effect * e : HitEffects)
        if (e->CanEffect(user, target))
            return true;
    return false;
}

// ConditionEffect **************************************************************************************

bool ConditionEffect::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    bool inflicted = target->AddCondition(InflictedCondition);
    if (inflicted)
    OUT_ALL << "        " << *target << " is now " << InflictedCondition << "." ALL_ENDL
    return inflicted;
}

void ConditionEffect::EndEffect(Actor * effected) const
{
    bool removed = effected->RemoveCondition(InflictedCondition);
    if (removed)
    OUT_ALL << "        " << *effected << " is no longer " << InflictedCondition << "." ALL_ENDL
}

bool ConditionEffect::CanEffect(const Actor & user, const Actor * target) const
{
    return target->HasImmunity(InflictedCondition);
}

// RepeatingEffect **************************************************************************************

bool RepeatingEffect::DoEffect(Actor & user, Actor * target, bool critical, Stat key_stat) const
{
    target->AddOngoingEffect(this, &user);
    return true;
}

void RepeatingEffect::EndEffect(Actor * effected) const
{}

bool RepeatingEffect::CanEffect(const Actor & user, const Actor * target) const
{
    for (Effect * e : DurationEffects)
        if (e->CanEffect(user, target))
            return true;
    for (Effect * e : RepeatingEffects)
        if (e->CanEffect(user, target))
            return true;
    return false;
}
